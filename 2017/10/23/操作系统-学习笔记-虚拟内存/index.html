<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>操作系统-学习笔记-虚拟内存 | 枳ukiyoe&#39;s</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="起因覆盖技术交换技术虚存技术

目标
程序局部性原理
基本概念
基本特征
虚拟页式内存管理

理想中的存储器：更大、更快、更便宜的非易失性存储器
在计算机系统中，尤其是在多道程序运行的环境下，可能会出现内存不够的情况，怎么办？

如果是程序太大，超过了内存的容量可以采用手动的覆盖(overlay)技术，只把需要的指令和数据保存在内存当中
如果是程序太多，超过了内存的容量，可以采用自动的交换(swa">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-学习笔记-虚拟内存">
<meta property="og:url" content="gensokyoukiyoe.github.io/2017/10/23/操作系统-学习笔记-虚拟内存/index.html">
<meta property="og:site_name" content="枳ukiyoe's">
<meta property="og:description" content="起因覆盖技术交换技术虚存技术

目标
程序局部性原理
基本概念
基本特征
虚拟页式内存管理

理想中的存储器：更大、更快、更便宜的非易失性存储器
在计算机系统中，尤其是在多道程序运行的环境下，可能会出现内存不够的情况，怎么办？

如果是程序太大，超过了内存的容量可以采用手动的覆盖(overlay)技术，只把需要的指令和数据保存在内存当中
如果是程序太多，超过了内存的容量，可以采用自动的交换(swa">
<meta property="og:updated_time" content="2017-10-24T14:35:38.972Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统-学习笔记-虚拟内存">
<meta name="twitter:description" content="起因覆盖技术交换技术虚存技术

目标
程序局部性原理
基本概念
基本特征
虚拟页式内存管理

理想中的存储器：更大、更快、更便宜的非易失性存储器
在计算机系统中，尤其是在多道程序运行的环境下，可能会出现内存不够的情况，怎么办？

如果是程序太大，超过了内存的容量可以采用手动的覆盖(overlay)技术，只把需要的指令和数据保存在内存当中
如果是程序太多，超过了内存的容量，可以采用自动的交换(swa">
  
    <link rel="alternate" href="/atom.xml" title="枳ukiyoe&#39;s" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <!--<link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">-->
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">枳ukiyoe&#39;s</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="gensokyoukiyoe.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-操作系统-学习笔记-虚拟内存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/23/操作系统-学习笔记-虚拟内存/" class="article-date">
  <time datetime="2017-10-23T14:37:42.000Z" itemprop="datePublished">2017-10-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS/">OS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      操作系统-学习笔记-虚拟内存
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>起因<br>覆盖技术<br>交换技术<br>虚存技术</p>
<ul>
<li>目标</li>
<li>程序局部性原理</li>
<li>基本概念</li>
<li>基本特征</li>
<li>虚拟页式内存管理</li>
</ul>
<p>理想中的存储器：<br>更大、更快、更便宜的非易失性存储器</p>
<p>在计算机系统中，尤其是在多道程序运行的环境下，可能会出现内存不够的情况，怎么办？</p>
<ul>
<li>如果是程序太大，超过了内存的容量可以采用手动的覆盖(overlay)技术，只把需要的指令和数据保存在内存当中</li>
<li>如果是程序太多，超过了内存的容量，可以采用自动的交换(swapping)技术，把暂时不能执行的程序送到外存中</li>
<li>如果想要在有限容量的内存中，以更小的页粒度为单位装入更多更大的程序，可以采用自动的虚拟存储技术</li>
</ul>
<h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p>目标：<br>是在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用</p>
<p>原理：<br>把程序按照其自身逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按时间先后来运行。</p>
<ul>
<li>必要部分(常用功能)的代码和数据常驻内存</li>
<li>可选部分(不常用功能)在其他程序模块中实现，平时存放在外存中，需要时才放到内存</li>
<li>不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖，即这些模块共用一个分区</li>
</ul>
<p>缺点：</p>
<ul>
<li>由程序员来把一个大的程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，费时费力，增长了编程的复杂度</li>
<li>覆盖模块由外存装入内存，实际上是以时间延长来换取空间节省</li>
</ul>
<h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p>目标:</p>
<ul>
<li><p>多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源</p>
</li>
<li><p>方法：<br>可将暂时不能运行的程序送到外存，从而获得空闲内存空间</p>
</li>
</ul>
<p>操作系统把一个进程的整个地址空间的内容保存到外存中(换出swap out)，而将外存的某个进程的地址空间读入到内存(swap in). 换入换出内容的大小为整个程序的地址空间</p>
<p>交换技术实现中的几个问题</p>
<ul>
<li>交换时机的确定：何时需要发生交换？只当内存空间不够或有不够的危险时换出；</li>
<li>交换区的大小：必须足够大以存放所有用户进程的所有内存映射的拷贝，必须能对这些内存映像进行直接存取</li>
<li>程序换入时的重定位：换出后再换入的内存位置一定要在原来的位置上吗？最好采用动态地址映射的方法</li>
</ul>
<h4 id="覆盖和交换的比较"><a href="#覆盖和交换的比较" class="headerlink" title="覆盖和交换的比较"></a>覆盖和交换的比较</h4><ul>
<li>覆盖只能发生在那些相互之间没有调用关系的程序模块之间，因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构。</li>
<li>交换技术是以内存中的程序大小为单位进行的，他不需要程序员给出程序内的各个模块之间的逻辑覆盖结构。<br>换言之，交换发生在内存中程序与管理程序或操作系统之间，而覆盖发生在运行程序的内部</li>
</ul>
<h4 id="虚存技术–目标"><a href="#虚存技术–目标" class="headerlink" title="虚存技术–目标"></a>虚存技术–目标</h4><p>在内存不够用的情形下，可以采用覆盖技术和交换技术，但是</p>
<ul>
<li>覆盖技术：需要程序员自己把整个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加程序员的负担</li>
<li>交换技术：以进程作为交换的单位，需要把进程的整个地址空间都换出换入，增大了处理器的开销</li>
</ul>
<p>目标<br>像覆盖技术那样，不是把程序的所有内容都放入内存中，因而能够运行比当前的空闲内存空间还要大的程序。但做的更好，又操作系统自己来完成，无须程序员的干涉</p>
<p>像交换技术那样，能够实现进程在内存和外存之间的交换，因而获得更多的空闲内存空间。但做得更好，只对进程的部分内容在内存和外存之间交换。</p>
<h4 id="虚存技术–程序的局部性原理"><a href="#虚存技术–程序的局部性原理" class="headerlink" title="虚存技术–程序的局部性原理"></a>虚存技术–程序的局部性原理</h4><ul>
<li>程序的局部性原理(principle of locality):指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限在一定的区域<br>–时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内；<br>–空间局部性：当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小的区域。</li>
</ul>
<p>程序的局部性原理表明，从理论上来讲，虚存技术是能够实现的，而且在实现了以后应该是能够取得一个满意的效果</p>
<h4 id="虚存技术–基本概念"><a href="#虚存技术–基本概念" class="headerlink" title="虚存技术–基本概念"></a>虚存技术–基本概念</h4><p>可以在页式或段式内存管理的基础上实现</p>
<ul>
<li><p>在装入程序时，不必将其全部装入到内存，而只需将当前需要执行的部分页面或段装入到内存，就可以让程序开始执行</p>
</li>
<li><p>在程序执行过程中，如果需执行的指令或访问的数据尚未在内存(称为缺页或缺段)，则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序</p>
</li>
<li><p>另一方面，操作系统将内存中暂时不使用的页面或段调出保存在外存上，从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面或段</p>
</li>
</ul>
<h4 id="虚存技术–基本特征"><a href="#虚存技术–基本特征" class="headerlink" title="虚存技术–基本特征"></a>虚存技术–基本特征</h4><p>大的用户空间：通过把物理内存与外存相结合，提供给用户的虚拟内存空间通常大于实际的物理内存，即实现了这两者的分离。如32位的虚拟地址理论上可以访问4GB，而可能计算机上仅有256M的物理内存，但硬盘容量大于4GB。</p>
<p>部分交换：与交换技术相比较，虚拟存储的调入与调出是对部分虚拟地址空间进行的</p>
<p>不连续性：物理内存分配的不连续，虚拟地址空间使用的不连续</p>
<h4 id="虚存技术–虚拟页式内存管理"><a href="#虚存技术–虚拟页式内存管理" class="headerlink" title="虚存技术–虚拟页式内存管理"></a>虚存技术–虚拟页式内存管理</h4><p>大部分虚拟存储系统都是采用虚拟页式存储管理技术，即在页式存储管理的基础上，增加请求调页和页面置换功能</p>
<p>基本思路：<br>当一个用户程序需要调入内存运行时，不是将该程序的所有页面都装入内存，而是只装入部分的页面，就可启动程序运行<br>在运行的过程中，如果发现要运行的程序或要访问的数据不在内存，则向系统发出缺页中断请求，系统在处理这个中断时，将外存中相应的页面调入内存，使得该程序能够继续运行</p>
<h4 id="后备存储-backing-Store"><a href="#后备存储-backing-Store" class="headerlink" title="后备存储(backing Store)"></a>后备存储(backing Store)</h4><p>在何处保存未被映射的页？</p>
<ul>
<li>能够简单地识别在二级存储器中的页</li>
<li>交换空间(磁盘或者文件)：特殊格式，用于存储未被映射的页面</li>
</ul>
<p>概念：后备存储</p>
<ul>
<li>一个虚拟地址空间的页面可以被映射到一个文件(在二级存储中)中的某个位置</li>
<li>代码段：映射到可执行二进制文件</li>
<li>动态加载的共享库程序段：映射到动态调用的库文件</li>
<li>其他段：可能被映射到交换文件(swap file)</li>
</ul>
<h4 id="虚拟内存性能"><a href="#虚拟内存性能" class="headerlink" title="虚拟内存性能"></a>虚拟内存性能</h4><p>为了便于理解分页的开销，使用有效存储器访问时间effective memory access time(EAT)</p>
<ul>
<li>EAT = 访存时间 <em> 页表命中率+page fault处理时间 </em> page fault 几率</li>
</ul>
<p>例子：<br>访存时间：10ns<br>磁盘访问时间：5ms<br>参数p=page fault几率<br>参数q=dirty page几率</p>
<p>EAT =10(1-p) + 5,000,000p(1+q)</p>
<p>EAT 主要取决于p</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="gensokyoukiyoe.github.io/2017/10/23/操作系统-学习笔记-虚拟内存/" data-id="cj9cwm2p5001k0ww990g7bepd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/10/24/操作系统-学习笔记-最优页面置换算法/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          操作系统-学习笔记-最优页面置换算法
        
      </div>
    </a>
  
  
    <a href="/2017/10/23/uml-学习笔记-RationalRose使用/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">uml-学习笔记-RationalRose使用</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hobby/">hobby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/uml/">uml</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hobby/">hobby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/literature/">literature</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/notes/">notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/plans/">plans</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uml/">uml</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/OS/" style="font-size: 20px;">OS</a> <a href="/tags/hobby/" style="font-size: 10px;">hobby</a> <a href="/tags/literature/" style="font-size: 16.67px;">literature</a> <a href="/tags/notes/" style="font-size: 10px;">notes</a> <a href="/tags/plans/" style="font-size: 13.33px;">plans</a> <a href="/tags/uml/" style="font-size: 10px;">uml</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/10/29/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2017/10/26/操作系统-学习笔记-二级机会法/">操作系统-学习笔记-二级机会法</a>
          </li>
        
          <li>
            <a href="/2017/10/26/电子烟/">电子烟</a>
          </li>
        
          <li>
            <a href="/2017/10/25/操作系统-学习笔记-时钟页面置换算法/">操作系统-学习笔记-时钟页面置换算法</a>
          </li>
        
          <li>
            <a href="/2017/10/25/操作系统-学习笔记-最近最久未使用算法/">操作系统-学习笔记-最近最久未使用算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 枳ukiyoe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>